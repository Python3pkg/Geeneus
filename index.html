<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Geeneus by rednaxela</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1 class="header">Geeneus</h1>
        <p class="header">Hyper simple protein and gene API for Entrez NCBI databases</p>

        <ul>
                 <li><a class="buttons github" href="https://github.com/rednaxela/Geeneus">View On GitHub</a></li>
        </ul>

        <p class="header">This project is maintained by <a class="header name" href="https://github.com/rednaxela">rednaxela</a></p>


      </header>
      <section>
        <h1>geeneus</h1>

<h3>Remote protein record access made simple</h3>

<hr><p><strong>01/07/2013</strong></p>

<p><em>THIS PAGE IS CURRENTLY IN ANTICIPATION OF THE 0.1.6 RELEASE, WHICH HASN'T HAPPENED YET, although it's available through github as the dev version. I'm hoping to push 0.1.6 out tomorrow or the day after, after more extensive testing to make sure the re-writes and new functionality deal with any edge cases accordingly ~ Alex</em></p>

<hr><p><strong>NOTE: This github page hosts the development version, but not the distribution version. To get and install the current stable version of <code>geeneus</code> use <code>pip</code></strong></p>

<pre><code>   sudo pip install geeneus
</code></pre>

<p>**The command above will install the current stable release. **</p>

<h3>Introduction</h3>

<p><strong>geeneus</strong> is designed as a simple to use, robust and reliable Python API to obtain biological record information (currently only protein data is supported). The tool primarily uses NCBI's protein database, but falls back on the EBI UniProt database in a totally seamless fashion if needed.</p>

<p>The motivation comes from the simple fact that when I began working with NCBI's databases I wanted an interface which allowed me to do:</p>

<pre><code>   interface.get_protein_sequence(accession_number)
</code></pre>

<p>and would just return the sequence associated with that accession number. This didn't exist, so I decided to create it.</p>

<p>The primary focus of <strong>geeneus</strong> from day 1 has been ease of use. NCBI allows access to their records through an Entrez based RESTful API called <a href="http://www.ncbi.nlm.nih.gov/books/NBK25500/">eUtils</a>. However, this can be complicated to set up, and to people who are less used to networking or programming can pose a major barrier to access. <a href="http://biopython.org/">Biopython</a> goes some way <a href="http://biopython.org/DIST/docs/tutorial/Tutorial.html#htoc98">to help with this</a>, but still requires the user to parse XML, deal with networking, read handles, and lots of other things which are just more work.</p>

<p>Considering this, my goals were to;</p>

<ul>
<li><p>Parse the returned XML - the user should <em>never</em> have to deal with XML unless they want to (note the raw XML associated with a record is still easily available!)</p></li>
<li><p>Deal with all the networking errors - the user should be able to turn their internet connection off while running and the system won't crash (it will probably stop getting results though)</p></li>
<li><p>Abstract any of the complexity to create a uniform and easy to use, API which returns built-in types. This means the various functions only return strings, lists, tuples and dictionaries.</p></li>
</ul><h3>Installation</h3>

<p>The simplest way to is to just use <code>pip</code> (note there's no need to download anything here, <code>pip</code> downloads the source from the package index database and then installs it)</p>

<pre><code>   pip install geeneus # (may need to be sudo)
</code></pre>

<p>More installation options can be found <a href="http://pypi.python.org/pypi/Geeneus/">here</a></p>

<h3>Usage</h3>

<p>For now only protein record access usage is provided, as the gene record functionality is still in development. However, the backend provides an extendable framework for abstracting networking, caching records and error handling, such that the addition of additional data types is reasonably straight forward (i.e. the only additional code needed is record type specific XML parsing)</p>

<p><strong>geeneus</strong> as a package contains a module for each type of record you might want to parse (protein, gene etc). To set up for protein records, you do;</p>

<pre><code>   from geeneus import Proteome
   manager = Proteome.ProteinManager("your.emailaddress@email.com")
</code></pre>

<p>And from there, the NCBI/UniProt protein data is at your fingertips. Say we want the sequence for the <em>protein sprouty homolog 4 isoform 2</em>. This protein has the accession number "<code>NP_001120968</code>", so we simply do</p>

<pre><code>   manager.get_protein_sequence("NP_001120968")
</code></pre>

<p>and we're greeted with the sequence (formatting for easy reading here)</p>

<pre><code>   'meppipqsap ltpnsvmvqp lldsrmshsr lqhpltilpi dqvktshve ndyidnpsla 
    lttgpkrtrg gapelaptpa rcdqdvthhw isfsgrpssv ssssstssd qrlldhmapp          
    pvadqaspra vriqpkvvhc qpldlkgpav ppeldkhfll ceacgkckc kecasprtlp 
    scwvcnqecl csaqtlvnyg tcmclvqgif yhctneddeg scadhpcsc srsnccarws
    fmgalsvvlp cllcylpatg cvklaqrgyd rlrrpgcrck htnsvicka asgdaktsrp 
    dkpf'
</code></pre>

<p>For the full range of functions available see below, or try <code>help(manager)</code> or <code>help(geneeus.Proteome)</code>. </p>

<h2>Functions</h2>

<p>Below there is a brief reference list for the available functions. The '*datastore*' being mentioned here refers to the internal storage structure that holds the data as it's parsed and stored.</p>

<h3>List of access modules</h3>

<pre><code>Proteome # for accessing protein data
Genome   # for accessing gene information (currently non-functional)
</code></pre>

<h3>List of Proteome functions</h3>

<h4>Protein Manager initializer parameters (default in parenthesese)</h4>

<pre><code>email        # required for NCBI database access

cache (True) # True or False: If set to True then the datastore
               cache's records, while if False a new record is 
               downloaded on every request. Unless you have a 
               very specific reason it is highly recommended to
               keep this as True

retry (0)    # Number of retries the NCBI networking protocols use                
               if access fails
</code></pre>

<h4>Introspective functions (queries relating to the datastore)</h4>

<pre><code>has_key(ID)         # check if an ID is currently cached in 
                      the datastore (does not trigger downloading
                      on False)

keys()              # returns a list of all the protein IDs in the              
                      datastore

datastore_size()    # get the number of records in the datastore

purge()             # delete all data from the datastore

error(ID)           # See if the record associated with this ID
                      caused an error (discussed below in more
                      detail)

exists(ID)          # See if the protein record associated with 
                      this ID exists (discussed below in more  
                      detail)

run_translation(ID) # function to translate an accession to a GI 
                      (uses a call to the NCBI lookup server)
</code></pre>

<h4>Protein record functions (queries relating to the record)</h4>

<pre><code>get_record_source(ID)        # determine which database this 
                               record was downloaded from (will 
                               return either 'NCBI' or 'UniProt')

get_record_creation_date(ID) # get the date the record was created
                               in the database (not the datastore) 

get_record_version(ID)       # get the record version (discussed     
                               in more detail below)

get_ID_type(ID)              # returns a 2 position list where  
                               [0] is an exit code and [1] is 
                               the name of the ID type (if it 
                               meets the criterion for any 
                               specific type
</code></pre>

<h4>Protein information functions (queries relating to the protein)</h4>

<pre><code>get_raw_xml(ID)                 # get an XML string for the record

get_protein_name(ID)            # get the protein name

get_protein_sequence(ID)        # get the amino acid sequence

get_protein_sequence_length(ID) # get number of amino acids in 
                                  sequence

get_geneID(ID)                  # if the protein is associated 
                                  with a specific gene ID then 
                                  this returns that ID

get_gene_name(ID)               # if the protein is associated 
                                  with a specific gene then 
                                  this returns that gene's name

get_variants(ID)                # get a list of variant 
                                  dictionaries (covered in detail 
                                  in a later section)

get_isoforms(ID)                # get a list of isoforms indexed
                                  by their isoform reference 
                                  (covered in detail in a later
                                  section)

get_domains(ID)                 # get a list of the PFAM 
                                  identified domains (covered in
                                  detail later)

get_other_accessions(ID)        # get a list of other accessions
                                  which also point at this record

get_taxonomy(ID)                # get the ordered taxonomy list of
                                  the species this protein  
                                  originates from

get_species(ID)                 # get the species of origin
</code></pre>

<h4>Batch protein information functions</h4>

<pre><code>batch_get_protein_sequence(List) # returns a list which  
                                   corresponds with the input list
                                   of protein sequences

batch_get_protein_name(List)     # returns a list which  
                                   corresponds with the input list
                                   of protein names

batch_get_variants(List)         # returns a list which  
                                   corresponds with the input list
                                   of protein variants lists
</code></pre>

<h4>Genome functions</h4>

<pre><code>Currently untested, so best to ignore for the time being...
</code></pre>

<h2>Complex return types</h2>

<p>Domains, variants, isoforms and other_accessions queries return complex structures (i.e. not a string or an integer). To understand what is being returned we brielfly summarize them here. We also have a quick discussion on version numbers and on <code>error</code> and <code>exists</code> statuses.</p>

<h4>Domains</h4>

<p>A domain query returns a list of domain dictionaries, where each dictionary has the following key value pairs;</p>

<pre><code>start        # domain start location
stop         # domain stop location
type         # domain type (currently always `pfam`, but left in for 
               potential upgrades to different domain recognition 
               approaches in the future)
label        # label information
accession    # accession associated with the domain
</code></pre>

<h4>Variants</h4>

<p><em>UPDATE IN 0.1.6: Previously he key names were capitalized (e.g. 'Location', 'Original' etc). To add consistency with other complex types keys are now all lower case</em></p>

<p>A variant query returns a list of variant dictionaries, where each dictionary has the following key value pairs;</p>

<pre><code>location   # start location of the variant being reported
original   # original amino acid(s) at location
mutant     # new amino acid(s) at location
variant    # a convenient X -&gt; Y string for easy visualization of
             what the variant is
type       # One of the following possible variant types, 
            "Deletion", "Insertion", "Substitution (single)," or
            "Substitution (double)
notes      # any annotation provided in the reference database as
             well as mutation references where possible
</code></pre>

<p>One potentially confusing is the use of DNA-typical vocabulary (insertion, deletion and subsitution) when talking about variant changes. It was decided that these provide appropriate and easy to understand terms, even if they typically refer to changes in DNA, not amino acid sequence. It's important to remember that a single substitution of an amino acid does not necessarily correspond to a SNP, and these descriptions refer <em>exclusively</em> to changes to the amino acid sequence, not the underlying DNA sequence.</p>

<h4>Isoforms</h4>

<p>Isoform queries return dictionary, where each key value is keyed by the isoform ID (which has the form "accession-X" e.g. Q12345-3). The value is a 2 position list, where position 0 is the isoform name/reference number and position 1 is the full isoform sequence. </p>

<p>For example, a protein with one isoform (Q12345-2) might return the following dictionary</p>

<pre><code>   {'Q1234-2':['2','GTAGHKLPKKLRSDF']}
</code></pre>

<p>Isoforms present some difficulties. Isoforms are defined in NCBI records in two different ways.</p>

<p>One set are based on feature annotation. A canonical record will have a number of features which describe the change in the various isoforms relative to that canonical sequence. Those isoforms don't have their own records - they exist as annotations in a canonical record and their sequences are represented as Q12345-X. <strong>geeneus</strong> can reconstruct these isoform amino acid sequences based on the annotations, which is how it builds the NCBI isoform lists (UniProt isoforms are each individually defined and linked to the reference record, so no reconstruction is required). One additional complication is that each isoform has both an isoform ID (Q12345-X) and an isoform name (isoform Y). While often X and Y are the same this is not always the case, sometimes Y is a word name (such a small, short, beta etc). More unhelpfully, sometimes Y is a number, but a <em>different</em> number to the isoform ID X value. </p>

<p>The other set exist as stand alone records, often with "isoform" in their name. These records unhelpfully includes no references to other isoforms, or to the canonical sequence/record from which they relate to. Similarly, canonical sequences have no reference to their "isoform" records. As such there is no way to include these in the list of isoforms (although they do have their own accession values as a result of existing as their own records). It is therefore up to the user to identify such isoforms. Theoretically, you could query the entire list of cross-referenced accessions and compare names to try and identify isoforms, but this would be a hugely expensive (in terms of network traffic) and there's no guarantee any/all isoforms would be included in the cross reference section.</p>

<p><strong>NB:</strong> If you want to request a specific isoform sequence using the dash notation, doing </p>

<pre><code>   manager.get_protein_sequence("Q12345-5") 
</code></pre>

<p>will return <strong>the canonical sequence</strong>, not the isoform sequence.</p>

<p>Instead, you need to do</p>

<pre><code>   manager.get_isoforms("Q12345-5")["Q12345-5"][1]
   # or
   manager.get_isoforms("Q12345")["Q12345-5"][1]
</code></pre>

<p>This will do the following</p>

<ul>
<li>Get the record associated with <code>Q12345</code>, then get the isoforms</li>
<li>Pull out the isoform data associated with <code>Q12345-5</code>
</li>
<li>As discussed above, the isoform data is a tuple of (<code>name</code>, <code>sequence</code>) so position 1 gives you the sequences</li>
</ul><p>It would probably be wise to wrap this in a <code>try/except</code> block in case the isoform ID is missing, such as</p>

<pre><code>   try:
      manager.get_isoforms("Q12345-5")["Q12345-5"][1]
   except KeyError:
      print "Isoform ID not found"
</code></pre>

<h4>Other accession</h4>

<p>Other accession queries returns a list of tuples which define, (<code>type of accession</code>, <code>accession</code>).  The type of accession will be one of the following;</p>

<ul>
<li>Swissprot</li>
<li>RefSeq</li>
<li>GI</li>
<li>PDB</li>
<li>UniProt</li>
<li>International Protein Index</li>
<li>DDBJ</li>
<li>GenBank</li>
<li>EMBL</li>
<li>Unknown accession type</li>
</ul><p>The way <strong>geeneus</strong> classifies these accession types is based on a set of hardcoded regular expressions. If you expect one accession type to be classified as something it's not, this may be an error in either how these values are parsed or the defining regular expressions, so please submit a bug report!</p>

<h2>Record versions</h2>

<p>Accession versioning is done by appending a period followed by a version number, e.g. Q12345.1 or Q12345.2 would be two different versions of the same record. Versioning represents updates made to records, typically as new information becomes available.</p>

<p>One potential source of problems is that NCBI records obtained directly through the eUtils interface (as opposed to through the website) do not contain any information on related versions. This means that geenes is unable to give this information either.</p>

<p>Querying a non-versioned accession (e.g. Q12345 or NP_1234567) will give the most up-to-date record associated with that accession, while querying a versioned value (Q12345.3 or NP_1234567.5) will give that specific version. However, there is no way to know if any specific versioned record is the most up-to-date record, or access previous records. This is not <em>necessarily</em> a problem, it's just worth being aware that if you query with explicit version numbers this may not give the most up to date version. </p>

<p>Note that GI numbers are unique for each different version, so deal with versioning in a different manner. The <code>version</code> number returned here refers to the non-GI accession version, where available. If no explicit version is available then we assume the version is 1.</p>

<h2>Error and Exists status</h2>

<p><code>error</code> and <code>exists</code> represent two flags to help deal with problems.    If a networking request fails, this sets a records <code>error</code> flag to true, and any of the other methods return <code>None</code>. In this case, <code>exist</code> is also set to False, as the record does not exist in the datastore. </p>

<p>Sometimes we may obtain a record correctly and without error, but find that it does not represent a valid protein record. If this happens we have not triggered an error (so error=False), but the record does not exists, in which case <code>exist</code> is also set to False. In these instances all methods <em>except</em> the <code>get_raw_xml()' method return</code>None<code>, but</code>get_raw_xml()` will return the xml for further inspection.</p>

<p><em>UPDATE IN 0.1.6: Previously if an error=True or exists=False the methods would return empty strings, lists of dictionaries. This can be dangerously ambiguous, so the behavior was changed to return None (equivalent to NA, or unknown)</em></p>

<h2>Design Decisions</h2>

<h3>UniProt fallback</h3>

<p>NCBI guarentees support for UniProt/Swissprot IDs which begin with O, P or Q. However, it also offers some support for other types of UniProt IDs (i.e. those which begin with other letters). There is sometimes a discrepancy between those which are available through the website and through the eUtils interface, where the eUtils lookup fails on an accession that should succeed. To deal with this, <strong>geeneus</strong> can use UniProt IDs and fall back on the UniProt servers. Dealing with UniProt calls instead of NCBI calls is more expensive in terms of network traffic because it requires an addition batch request to the PFAM servers to define the domains. The UniProt records only hold references to PFAM domains, but lack the necessary details to build informative domain data structures.</p>

<p>Because of this additional network expense, UniProt requests are kept to a minimum - they are the fall back option. However, the user is totally oblivious to this behavior - <strong>geeneus</strong> provides an entirely uniform access to the information regardless of its source. To check which database a record has come from you can do</p>

<pre><code>   manager.get_record_source(ID)
</code></pre>

<p>Which returns the remote database type from which the record associated with accession ID was obtained. Note that if ID is not already in the datastore this will trigger the record to be fetched.</p>

<h3>Caching</h3>

<p>Local and temporary caching is an important feature of <strong>geeneus</strong> which helps make it an ideal tool for interactive data exploration. The manager object builds up a local data structure, and by default caches the records it fetches from remote database. The upshot of this from the user's perspective is that if I run</p>

<pre><code>manager.get_protein_sequence("NP_001120968")
manager.get_protein_sequence("NP_001120968")
</code></pre>

<p>The second call doesn't query the database, but just reads off the cached value. This caching behavior can be turned off on by setting <code>cache=False</code> when initializing the ProteinManager object.</p>

<h3>Batch queries</h3>

<p>A key design decision was how to deal with batch queries.</p>

<p>The eUtils recommended approach for making large (100+ IDs) queries is to initially ePost a list of those queries. The ePost operation sends this list to the ENTREZ servers, returning a <code>WebEnv</code> value and a <code>QueryKey</code> value. These two can then be used with an <code>eFetch</code> to go to the sever and get the result of the list submitted previously. The difficulty is that this list <em>must</em> be made up of UIDs (unique identifiers) which for proteins means GI numbers. If you only have an accession value (as is common) the only way to get this GI number is to query the database, and this <code>eSearch</code> operation can <em>not</em> be done in batch. Essentially, this is a chicken and egg problem - to get the GIs we need to do an <code>ePost</code> based batch query we have to run serial database queries.</p>

<p>This means that using <code>ePost</code>/<code>eFetch</code> would be great if you had a list of UIDs, but in practice accession numbers are a lot more common and useful, and the mapping of <em>n</em> accession values to UIDs would require <em>n</em> calls the server anyway. </p>

<p>To get around this, I use concatenated <code>eFetch</code> calls for batch queries, whereby a single call is submitted with a list of IDs. This is a fast and stable way to get around this problem, and, so far, as shown no issues with lists up to 100 IDs long. The potential issue is that the HTTP GET request being made here literally gets longer as we add accession values, so this represents a top limit in terms of networking protocols. However, I implemented a recursive cascading retry mechanism which halves the list and retries each half, so should a list be too long it should only result in two calls instead of one.</p>

<h3>Robustness</h3>

<p>A primary goal with <strong>geeneus</strong> was to create an API which is robust to input. By this, it should be able to handle case insensitivity, convert accession values where necessary, and correctly recognize valid accession values while rejecting irrelevant ones to minimize server burden. For accession filtering, we use regular expressions to ensure the only accession values which we query could be real values (based on NCBI's <a href="http://www.ncbi.nlm.nih.gov/Sequin/acc.html">accession rules</a>. While PDBs don't fall into this category, we allow translation between PDBID and GI, although often a chain identifier is required as the NCBI protein database treats separate chains as separate records.</p>

<p>All the networking is dealt with in a highly modular fashion, and network failure tolerance is a priority.</p>

<h3>Background and licence</h3>

<p>This code was developed by <a href="http://holehouse.org">Alex Holehouse</a> at <a href="http://www.wustl.edu/">Washington University in Saint Louis</a> as part of the <a href="http://naegle.wustl.edu/people/lab_members.html">Naegle lab</a>. It is licensed under the the GNU General Public License (GPL-2.0). For more information see LICENCE.</p>
      </section>
      <footer>
        <p><small>Hosted on <a href="https://pages.github.com">GitHub Pages</a> using the Dinky theme</small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
		          <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-26309586-2");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>
